#' VIPER
#'
#' This function performs Virtual Inference of Protein-activity by Enriched Regulon analysis
#'
#' @param eset ExpressionSet object or Numeric matrix containing the expression data or gene expression signatures, with samples in columns and genes in rows
#' @param regulon Object of class regulon
#' @param dnull Numeric matrix for the null model, usually generated by \code{nullTtest}
#' @param tw Number indicating the power transformation for target weight
#' @param lw Number indicating the power transformation for the likelihood weight
#' @param nes Logical, whether the enrichment score reported should be normalized
#' @param method Character string indicating the method for computing the single samples signature, either scale, rank, mad, ttest or none
#' @param minsize Integer indicating the minimum number of targets allowed per regulon
#' @param adaptive.size Logical, whether the weighting scores should be taken into account for computing the regulon size
#' @param eset.filter Logical, whether the dataset should be limited only to the genes represented in the interactome
#' @param nes.method Character string indicating the method for estimating the NES, either analytical, empirical or fit. Fit method is recommended only for large datasets (>500 samples)
#' @param verbose Logical, whether progression messages should be printed in the terminal
#' @return A matrix of inferred activity for each regulator gene in the network across all samples
#' @seealso \code{\link{msviper}}
#' @examples
#' data(bcellViper, package="bcellViper")
#' d1 <- exprs(dset)
#' res <- viper(d1, regulon)
#' dim(d1)
#' d1[1:5, 1:5]
#' regulon
#' dim(res)
#' res[1:5, 1:5]
#' @export

viper <- function(eset, regulon, dnull=NULL, tw=.5, lw=1, nes=TRUE, method=c("scale", "rank", "mad", "ttest", "none"), minsize=25, adaptive.size=FALSE, eset.filter=TRUE, nes.method="analytic", verbose=TRUE) {
    method <- match.arg(method)
    pdata <- NULL
    if (is(eset, "viperSignature")) {
        dnull <- eset$nullmodel
        eset <- eset$signature
        method="none"
    }
    if (is(eset, "ExpressionSet")) {
        pdata <- phenoData(eset)
        eset <- exprs(eset)
    } else if (is.data.frame(eset)) {
        eset<-as.matrix(eset)
    }
    if (eset.filter) {
        tmp <- c(names(regulon), unlist(lapply(regulon, function(x) names(x$tfmode)), use.names=FALSE))
        eset <- eset[rownames(eset) %in% unique(tmp), ]
    }
    if (verbose) message("\nComputing the association scores")
    switch(method,
    scale={tt <- t(scale(t(eset)))},
    rank={tt <- t(apply(eset, 1, rank))*punif(length(eset), -.1, .1)},
    mad={tt <- t(apply(eset, 1, function(x) (x-median(x))/mad(x)))},
    ttest={
        tt <- sapply(1:ncol(eset), function(i, eset) rowTtest(eset[, i]-eset[, -i])$statistic, eset=eset)
        colnames(tt) <- colnames(eset)
        rownames(tt) <- rownames(eset)
    },
    none={tt <- eset})
    regulon <- lapply(regulon, function(x, genes) {
        filtro <- names(x$tfmode) %in% genes
        x$tfmode <- x$tfmode[filtro]
        if (length(x$likelihood)==length(filtro)) x$likelihood <- x$likelihood[filtro]
        return(x)
    }, genes=rownames(eset))
    tw <- 1/table(unlist(lapply(regulon, function(x) names(x$tfmode)), use.names = FALSE))^tw
    if (adaptive.size) regulon <- regulon[sapply(regulon, function(x, tw) {
        t1 <- tw[match(names(x$tfmode), names(tw))]
        sum(x$likelihood*t1/max(x$likelihood*t1))
    }, tw=tw)>=minsize]
    else regulon <- regulon[sapply(regulon, function(x) length(x$tfmode))>=minsize]
    es <- pwea3NULLgroups(tt, regulon, tw=tw, lw=lw, verbose=verbose)
    if (!nes) {
        nes <- es$groups*es$ss
        colnames(nes) <- colnames(eset)
        return(nes)
    }
    if (is.null(dnull)) {
        switch(pmatch(nes.method, c("analytical", "empirical", "fit")),
        dnull <- ppwea3NULLf(regulon, tw=tw, lw=lw),
        dnull <- pwea3NULLf(es, verbose=verbose),
        dnull <- pwea3NULLf1(es))
    }
    else dnull <- pwea3NULLf(pwea3NULLgroups(dnull, regulon, tw=tw, lw=lw, verbose=verbose), verbose=verbose)
    pval <- t(sapply(1:length(dnull), function(i, es, dnull) dnull[[i]](es[i, ])$p.value, es=es$groups, dnull=dnull)) 
    nes <- qnorm(pval/2, lower.tail=FALSE)*es$ss
    rownames(nes) <- names(regulon)
    colnames(nes) <- colnames(eset)
    if (is.null(pdata)) return(nes)
    return(ExpressionSet(assayData=nes, phenoData=pdata))
}

##########
#' Generic S4 method for signature and sample-permutation null model for VIPER
#' 
#' This function generates a viperSignature object from a test dataset based on a set of samples to use as reference
#' 
#' @param eset ExpressionSet object or numeric matrix containing the test dataset, with genes in rows and samples in columns
#' @return viperSignature S3 object containing the signature and null model
#' @export
#' @docType methods
#' @rdname viperSignature-methods
setGeneric("viperSignature", function(eset, ...) standardGeneric("viperSignature"))

#' @param pheno Character string indicating the phenotype data to use
#' @param refgroup Vector of character string indicatig the category of \code{pheno} to use as reference group
#' @param per Integer indicating the number of sample permutations
#' @param seed Integer indicating the seed for the random sample generation. The system default is used when set to zero
#' @param verbose Logical, whether progression messages should be printed in the terminal
#' @examples
#' data(bcellViper, package="bcellViper")
#' ss <- viperSignature(dset, "description", c("N", "CB", "CC"))
#' res <- viper(ss, regulon)
#' dim(exprs(dset))
#' exprs(dset)[1:5, 1:5]
#' regulon
#' dim(res)
#' res[1:5, 1:5]
#' @rdname viperSignature-methods
#' @aliases viperSignature,ExpressionSet-method
setMethod("viperSignature", "ExpressionSet", function(eset, pheno, refgroup, per=1000, seed=1, verbose=TRUE) {
    pos <- pData(eset)[[pheno]] %in% refgroup
    if (length(pos)==0) stop(paste(pheno, " is not present in the ExpressionSet object", sep=""), call.=FALSE)
    if (length(which(pos))==0) stop(paste(refgroup, " was nor found in ", pheno, sep=""), call.=FALSE)
    tmp <- viperSignature(exprs(eset)[, !pos], exprs(eset)[, pos], per=per, seed=seed, verbose=verbose)
    pdata <- phenoData(eset)
    pData(pdata) <- pData(pdata)[match(colnames(tmp$signature), rownames(pData(pdata))), ]
    tmp$signature <- ExpressionSet(assayData=tmp$signature, phenoData=pdata)
    return(tmp)
})

#' @param ref Numeric matrix containing the reference samples (columns) and genes in rows
#' @examples
#' data(bcellViper, package="bcellViper")
#' d1 <- exprs(dset)
#' ss <- viperSignature(d1[, -(1:5)], d1[, 1:5])
#' res <- viper(ss, regulon)
#' dim(d1)
#' d1[1:5, 1:5]
#' regulon
#' dim(res)
#' res[1:5, 1:5]
#' @rdname viperSignature-methods
#' @aliases viperSignature,matrix-method
setMethod("viperSignature", "matrix", function(eset, ref, per=1000, seed=1, verbose=TRUE) {
    if (seed>0) set.seed(ceiling(seed))
    pb <- NULL
    if (verbose) pb <- txtProgressBar(max=per, style=3)
    vpsig <- apply(eset, 2, function(x, ctrl) {
        tmp <- rowTtest(x-ctrl)
        (qnorm(tmp$p.value/2, lower.tail=FALSE)*sign(tmp$statistic))[, 1]
    }, ctrl=ref)
    rownames(vpsig) <- rownames(eset)
    colnames(vpsig) <- colnames(eset)
    vpnull <- sapply(1:per, function(i, dset, pb, size, verbose) {
        if (verbose) setTxtProgressBar(pb, i)
        tmp <- NA
        while(any(is.na(tmp))) {
            pos <- sample(ncol(dset), size)
            tmp <- rowTtest(dset[, pos[1]]-dset[, pos[-1]])
            tmp <- (qnorm(tmp$p.value/2, lower.tail=FALSE)*sign(tmp$statistic))[, 1]
        }
        return(tmp)
    }, dset=cbind(eset, ref), size=ncol(ref)+1, pb=pb, verbose=verbose)
    rownames(vpnull) <- rownames(eset)
    tmp <- list(signature=vpsig, nullmodel=vpnull)
    class(tmp) <- "viperSignature"
    return(tmp)
})
